/* 

This is a Domain coloring class to plot complex functions
using different color schemes.

It requires the following libraries:

 1. p5.js https://p5js.org/, 
 2. HSL uv https://github.com/hsluv/hsluv
 3. complex.js

Written by Juan Carlos Ponce Campuzano 2020
https://jcponce.github.io/

Under Creative Commons License
https://creativecommons.org/licenses/by-sa/4.0/

Last update 3-Aug-2020

*/

class domainColoring{constructor(t,s,i=!0,h=0,e=0,o=1){this.frame=i,this.frame?(this.x=40,this.y=40,this.w=width-this.x,this.h=height-this.y):(this.x=0,this.y=0,this.w=width,this.h=height),this.sw=2*s,this.sh=this.sw*height/width,this.origSize=new p5.Vector(this.sw,this.sh),this.size=new p5.Vector(this.origSize.x,this.origSize.y),this.origPos=new p5.Vector(0,0),this.pos=new p5.Vector(this.origPos.x,this.origPos.y),this.origZoom=1,this.zoom=this.origZoom,this.printDebug=!1,this.func=this.verifyFunction(complex_expression(t,h,e,o));let r=map(this.pos.x,-this.size.x/2,this.size.x/2,this.x,this.w),l=map(this.pos.y,-this.size.y/2,this.size.y/2,this.y,this.h);this.bX=r,this.bY=l,this.sharp=.39,this.b=.655,this.nMod=2,this.nPhase=20,this.base=2}verifyFunction(t){let s;this.check=!0;try{s=t.fn}catch(i){if(null==s)return this.check=!1,t=complex_expression("0")}return t}selectOption(){"Phase"===this.opt?(this.funColorHSV=((t,s)=>this.cPhaseHSV(t,s)),this.funColorHSVDiscrete=((t,s)=>this.cPhaseHSVDiscrete(t,s)),this.funColorRGB=((t,s)=>this.cPhaseRGB(t,s))):"Modulus"===this.opt?(this.funColorHSV=((t,s)=>this.cModHSV(t,s)),this.funColorHSVDiscrete=((t,s)=>this.cModHSVDiscrete(t,s)),this.funColorRGB=((t,s)=>this.cModRGB(t,s))):"Phase/Modulus"===this.opt?(this.funColorHSV=((t,s)=>this.cPhaModHSV(t,s)),this.funColorHSVDiscrete=((t,s)=>this.cPhaModHSVDiscrete(t,s)),this.funColorRGB=((t,s)=>this.cPhaModRGB(t,s))):(this.funColorHSV=((t,s)=>1),this.funColorHSVDiscrete=((t,s)=>1),this.funColorRGB=((t,s)=>255)),"Real"===this.opt?(this.funColorSReIm=((t,s)=>1),this.funColorBReIm=((t,s)=>sqrt(sqrt(abs(sin(3*PI*t)))))):"Imaginary"===this.opt?(this.funColorSReIm=((t,s)=>1),this.funColorBReIm=((t,s)=>sqrt(sqrt(abs(sin(3*PI*s)))))):"Re/Im"===this.opt?(this.funColorSReIm=((t,s)=>1),this.funColorBReIm=((t,s)=>sqrt(sqrt(abs(sin(3*PI*s)*sin(3*PI*t)))))):"Modulus"===this.opt?(this.funColorSReIm=((t,s)=>this.satReIm(t,s)),this.funColorBReIm=((t,s)=>1)):"All"===this.opt?(this.funColorSReIm=((t,s)=>this.satReIm(t,s)),this.funColorBReIm=((t,s)=>this.SatValReIm(t,s))):"None"===this.opt&&(this.funColorSReIm=((t,s)=>1),this.funColorBReIm=((t,s)=>1)),"Phase"===this.opt?(this.funColorHSL=((t,s)=>this.cPhaseHSL(t,s)),this.funColorHSLuv=((t,s)=>this.cPhaseHSLuv(t,s))):"Modulus"===this.opt?(this.funColorHSL=((t,s)=>this.cModHSL(t,s)),this.funColorHSLuv=((t,s)=>this.cModHSLuv(t,s))):"Phase/Modulus"===this.opt?(this.funColorHSL=((t,s)=>this.cPhaModHSL(t,s)),this.funColorHSLuv=((t,s)=>this.cPhaModHSLuv(t,s))):"Standard"===this.opt?(this.funColorHSL=((t,s)=>this.funStdHSL(t,s)),this.funColorHSLuv=((t,s)=>this.funStdHSLuv(t,s))):(this.funColorHSL=((t,s)=>.5),this.funColorHSLuv=((t,s)=>.5)),"Phase"===this.opt?this.funColorBW=((t,s)=>this.val(t,s)):"Modulus"===this.opt?this.funColorBW=((t,s)=>this.sat(t,s)):"Phase/Modulus"===this.opt?this.funColorBW=((t,s)=>this.val(t,s)*this.sat(t,s)):"Real"===this.opt?this.funColorBW=((t,s)=>this.funRe(t,s)):"Imaginary"===this.opt?this.funColorBW=((t,s)=>this.funIm(t,s)):"Re/Im"===this.opt&&(this.funColorBW=((t,s)=>this.funRe(t,s)*this.funIm(t,s)))}funPhase(t,s){return(Math.PI-Math.atan2(s,-t))/(2*Math.PI)}funPhaseHSV(t,s){return(Math.PI-Math.atan2(s,-t))/(2*Math.PI)}cPhaseHSV(t,s){let i=this.nPhase*this.funPhaseHSV(t,s);return this.sharp*(i-floor(i))+this.b}cModHSV(t,s){let i=this.nMod*log(sqrt(t*t+s*s));return this.sharp*(i-floor(i))+this.b}cPhaModHSV(t,s){return this.cPhaseHSV(t,s)*this.cModHSV(t,s)}funColorHSV(t,s){return this.cModHSV(t,s)}plotHSV(t="Modulus"){this.backgroundPlot(),this.opt=t,this.selectOption(),loadPixels();for(let t=this.x;t<this.w;t++)for(let s=this.x;s<this.h;s++){let i,h,e,o,r;h={r:(i=new p5.Vector(this.pos.x+map(t,this.x,this.w,-this.size.x/2,this.size.x/2),this.pos.y+map(s,this.h,this.y,-this.size.y/2,this.size.y/2))).x,i:i.y},e=this.func.fn(h),o=this.funPhaseHSV(e.r,e.i),r=this.funColorHSV(e.r,e.i),this.setPixelHSV(t,s,o,1,r)}updatePixels(),this.grid()}funPhaseReIm(t,s){return(PI-atan2(s,-t))/(2*PI)}satReIm(t,s){let i=log(sqrt(t*t+s*s))/log(2);return abs(3*sin(2*PI*(i-floor(i))))}valReIm(t,s){let i=abs(sin(3*PI*s)*sin(3*PI*t));return sqrt(sqrt(i))}SatValReIm(t,s){let i=1-this.satReIm(t,s)-this.valReIm(t,s);return.5*(1-this.satReIm(t,s)+this.valReIm(t,s)+sqrt(i*i+.01))}funColorSReIm(t,s){return 1}funColorBReIm(t,s){return this.valReIm(t,s)}plotHSVReIm(t="Re/Im"){this.backgroundPlot(),this.opt=t,this.selectOption(),loadPixels();for(let t=this.x;t<this.w;t++)for(let s=this.x;s<this.h;s++){let i,h,e,o,r,l;h={r:(i=new p5.Vector(this.pos.x+map(t,this.x,this.w,-this.size.x/2,this.size.x/2),this.pos.y+map(s,this.h,this.y,-this.size.y/2,this.size.y/2))).x,i:i.y},e=this.func.fn(h),o=this.funPhaseReIm(e.r,e.i),r=this.funColorSReIm(e.r,e.i),l=this.funColorBReIm(e.r,e.i),this.setPixelHSV(t,s,o,r,l)}updatePixels(),this.grid()}funPhaseHSVDiscrete(t,s){return atan2(s,t)}cPhaseHSVDiscrete(t,s){let i=this.nPhase*this.funPhaseHSV(t,s);return this.sharp*(i-floor(i))+this.b}cModHSVDiscrete(t,s){let i=this.nMod*log(sqrt(t*t+s*s));return this.sharp*(i-floor(i))+this.b}cPhaModHSVDiscrete(t,s){return this.cPhaseHSVDiscrete(t,s)*this.cModHSVDiscrete(t,s)}funColorHSVDiscrete(t,s){return this.cModHSVDiscrete(t,s)}plotHSVDisc(t="Modulus"){this.backgroundPlot(),this.opt=t,this.selectOption(),loadPixels();for(let t=this.x;t<this.w;t++)for(let s=this.x;s<this.h;s++){let i,h,e,o,r;h={r:(i=new p5.Vector(this.pos.x+map(t,this.x,this.w,-this.size.x/2,this.size.x/2),this.pos.y+map(s,this.h,this.y,-this.size.y/2,this.size.y/2))).x,i:i.y},e=this.func.fn(h),o=this.funPhaseHSVDiscrete(e.r,e.i),r=this.funColorHSVDiscrete(e.r,e.i),0<=o&&o<PI/6||-PI/6<=o&&o<0?this.setPixelHSV(t,s,0,1,r):-5*PI/6<o&&o<=-PI/2?this.setPixelHSV(t,s,.66,1,r):PI/2+PI/20<=o&&o<5*PI/6?this.setPixelHSV(t,s,.333,1,r):PI/2-PI/20<o&&o<PI/2+PI/20?this.setPixelHSV(t,s,.166,1,r):PI/6<o&&o<=PI/2-PI/20?this.setPixelHSV(t,s,.083,1,r):-PI/2<o&&o<=-PI/6?this.setPixelHSV(t,s,.75,1,r):-PI<=o&&o<=-5*PI/6||5*PI/6<o&&o<=PI?this.setPixelHSV(t,s,.499,1,r):this.setPixelHSV(t,s,1,0,0)}updatePixels(),this.grid()}funPhaseHSVGrad(t,s){return(Math.PI-Math.atan2(s,-t))/(2*Math.PI)}satHSVGrad(t,s){return(1+abs(sin(2*PI*this.funColorHSVGrad(t,s))))/2}valHSVGrad(t,s){return(1+abs(cos(2*PI*this.funColorHSVGrad(t,s))))/2}funColorHSVGrad(t,s){return log(1+sqrt(t*t+s*s))}plotHSVG(){this.backgroundPlot(),loadPixels();for(let t=this.x;t<this.w;t++)for(let s=this.x;s<this.h;s++){let i,h,e,o,r,l;h={r:(i=new p5.Vector(this.pos.x+map(t,this.x,this.w,-this.size.x/2,this.size.x/2),this.pos.y+map(s,this.h,this.y,-this.size.y/2,this.size.y/2))).x,i:i.y},e=this.func.fn(h),o=this.funPhaseHSVGrad(e.r,e.i),r=pow(this.satHSVGrad(e.r,e.i),1.3),l=pow(this.valHSVGrad(e.r,e.i),1.3),this.setPixelHSV(t,s,o,r,l)}updatePixels(),this.grid()}funPhaseRGB(t,s){return(Math.PI-Math.atan2(s,-t))/(2*Math.PI)*255-20}cPhaseRGB(t,s){let i=this.nPhase*(Math.PI-Math.atan2(s,-t))/(2*Math.PI);return 255*(this.sharp*(i-floor(i))+this.b)}cModRGB(t,s){let i=this.nMod*log(sqrt(t*t+s*s));return 255*(this.sharp*(i-floor(i))+this.b)}cPhaModRGB(t,s){return this.cPhaseRGB(t,s)*this.cModRGB(t,s)/255}funColorRGB(t,s){return this.cModRGB(t,s)}plotRGB(t="Modulus"){this.backgroundPlot(),this.opt=t,this.selectOption(),loadPixels();for(let t=this.x;t<this.w;t++)for(let s=this.y;s<this.h;s++){let i,h,e,o,r,l;h={r:(i=new p5.Vector(this.pos.x+map(t,this.x,this.w,-this.size.x/2,this.size.x/2),this.pos.y+map(s,this.h,this.y,-this.size.y/2,this.size.y/2))).x,i:i.y},e=this.func.fn(h),o=this.funPhaseRGB(e.r,e.i),r=this.funColorRGB(e.r,e.i)-50,l=180,this.setPixelRGB(t,s,o,r,l)}updatePixels(),this.grid()}funPhaseHSL(t,s){return(Math.PI-Math.atan2(s,-t))/(2*Math.PI)}funStdHSL(t,s){return 2/(1+exp(-sqrt(t*t+s*s)))-1}cPhaseHSL(t,s){let i=this.nPhase*this.funPhaseHSL(t,s);return this.sharp*(i-floor(i))+this.b}cModHSL(t,s){let i=this.nMod*log(sqrt(t*t+s*s));return this.sharp*(i-floor(i))+this.b}cPhaModHSL(t,s){return this.cPhaseHSL(t,s)*this.cModHSL(t,s)}funColorHSL(t,s){return this.cModHSL(t,s)}plotHSL(t="Modulus"){this.backgroundPlot(),this.opt=t,this.selectOption(),loadPixels();for(let t=this.x;t<this.w;t++)for(let s=this.y;s<this.h;s++){let i,h,e,o,r,l;h={r:(i=new p5.Vector(this.pos.x+map(t,this.x,this.w,-this.size.x/2,this.size.x/2),this.pos.y+map(s,this.h,this.y,-this.size.y/2,this.size.y/2))).x,i:i.y},e=this.func.fn(h),o=this.funPhaseHSL(e.r,e.i),r=1,l=this.funColorHSL(e.r,e.i),this.setPixelHSL(t,s,o,r,l)}updatePixels(),this.grid()}funPhaseHSLuv(t,s){return(Math.PI-Math.atan2(s,-t))/(2*Math.PI)}funStdHSLuv(t,s){return 2/(1+exp(-sqrt(t*t+s*s)))-1}cPhaseHSLuv(t,s){let i=this.nPhase*this.funPhaseHSLuv(t,s);return this.sharp*(i-floor(i))+this.b}cModHSLuv(t,s){let i=this.nMod*log(sqrt(t*t+s*s));return this.sharp*(i-floor(i))+this.b}cPhaModHSLuv(t,s){return this.cPhaseHSLuv(t,s)*this.cModHSLuv(t,s)}funColorHSLuv(t,s){return this.cModHSLuv(t,s)}plotHSLuv(t="Modulus",s=0,i=1){this.backgroundPlot(),this.opt=t,this.selectOption(),loadPixels();for(let t=this.x;t<this.w;t++)for(let h=this.y;h<this.h;h++){let e,o,r,l,n,u;o={r:(e=new p5.Vector(this.pos.x+map(t,this.x,this.w,-this.size.x/2,this.size.x/2),this.pos.y+map(h,this.h,this.y,-this.size.y/2,this.size.y/2))).x,i:e.y},r=this.func.fn(o),l=map(this.funPhaseHSLuv(r.r,r.i),0,1,s,i),n=1,u=this.funColorHSLuv(r.r,r.i),this.setPixelHSLuv(t,h,l,n,u)}updatePixels(),this.grid()}funRe(t,s){let i,h=t;return i=round(2)*h-floor(round(2)*h)<.5?1:-1}funIm(t,s){let i,h=s;return i=round(2)*h-floor(round(2)*h)<.5?1:-1}sat(t,s){let i,h=log(sqrt(t*t+s*s))/log(2);return i=round(10/7)*h-floor(round(10/7)*h)<.5?1:-1}val(t,s){let i,h=round(10)*this.funPhase(t,s);return i=h-floor(h)<.5?1:-1}funColorBW(t,s){this.sat(t,s)}plotBW(t="Modulus"){let s,i;this.backgroundPlot(),this.opt=t,this.selectOption(),loadPixels();for(let t=this.x;t<this.w;t++)for(let h=this.y;h<this.h;h++){let e,o,r,l;o={r:(e=new p5.Vector(this.pos.x+map(t,this.x,this.w,-this.size.x/2,this.size.x/2),this.pos.y+map(h,this.h,this.y,-this.size.y/2,this.size.y/2))).x,i:e.y};let n=(r=this.func.fn(o)).r,u=r.i;n<.5?(s=n,s=1):s=-1,u<.5?(i=u,i=1):i=-1,l=this.funColorBW(n,u),this.setPixelHSL(t,h,1,0,l)}updatePixels(),this.grid()}grid(){if(push(),fill(0),stroke(0),strokeWeight(.5),textSize(16),textAlign(LEFT),text("Re",this.w+10,this.h),pop(),push(),fill(0),stroke(0),strokeWeight(.5),textSize(16),textAlign(RIGHT),text("Im",this.x,this.y-19),pop(),width>350&&height>350){push(),fill(0),stroke(0),noStroke(),textSize(18),textAlign(LEFT);round(1/this.zoom*1e3);let t,s,i=this.x+10,h=this.y-10;if(t=this.pos.x+map(mouseX,this.x,this.w,-this.size.x/2,this.size.x/2),s=this.pos.y+map(mouseY,this.h,this.y,-this.size.y/2,this.size.y/2),!0===this.dragging)text("Mouse z: (-,-)",i,h);else if(this.x<mouseX&&mouseX<this.w&&this.y<mouseY&&mouseY<this.h){let e={r:t,i:s},o=this.func.fn(e);text("Mouse z: ("+str(round(100*t)/100)+","+str(round(100*s)/100)+")",i,h),text("f(z): ("+str(round(100*o.r)/100)+","+str(round(100*o.i)/100)+")",this.w/2+50,h),cursor("crosshair")}pop()}push();let t,s;.003<=1/this.zoom&&1/this.zoom<.006?(s=.5,t=12):.001<=1/this.zoom&&1/this.zoom<.003?(s=.4,t=10):1e-4<=1/this.zoom&&1/this.zoom<.001?(s=.3,t=9):1/this.zoom<1e-4?(s=.1,t=7):(s=.5,t=13),textSize(t);for(let t=this.x;t<this.w+this.x;t+=(this.w-1*this.x)/4){let i=map(t,this.x,this.w,-this.size.x/2,this.size.x/2);fill(0),stroke(0),strokeWeight(s),textAlign(CENTER),text(""+str(round(100*(this.pos.x+i))/100),t,this.h+20),fill(0),noStroke(),ellipse(t,this.h,2.5)}for(let t=this.y;t<=this.h+this.y;t+=(this.h-1*this.y)/4){let i=map(t,this.h,this.y,-this.size.y/2,this.size.y/2);fill(0),stroke(0),strokeWeight(s),textAlign(RIGHT),text(""+str(round(100*(this.pos.y+i))/100),this.x-2,t-3),fill(0),noStroke(),ellipse(this.x,t,2.5)}pop(),this.check||(push(),fill(255),rect(0,0,width,height),fill(0),textSize(width/100*6),textAlign(CENTER),text("Something went wrong 😟! \n Please, check your input!",width/2,height/2),pop()),this.printDebug&&(stroke(20),strokeWeight(1),line(this.w/2+this.x/2,this.x,this.w/2+this.x/2,this.h),line(this.y,this.h/2+this.y/2,this.w,this.h/2+this.y/2),ellipse((this.w+this.x)/2,(this.h+this.y)/2,8,8))}backgroundPlot(){push(),fill(255),rect(0,0,width,height),noFill(),stroke(100),strokeWeight(.5),rect(this.x,this.y,this.w-this.x,this.h-this.y),pop(),cursor(ARROW)}zoomAt(t,s,i,h){let e,o,r,l;i=h?i:1/i,e=map(t,this.x,this.w,this.pos.x-this.size.x/2,this.pos.x+this.size.x/2),o=map(s,this.h,this.y,this.pos.y-this.size.y/2,this.pos.y+this.size.y/2),this.pos.x=e+(this.pos.x-e)*i,this.pos.y=o+(this.pos.y-o)*i,this.zoom*=i,this.size.x=this.origSize.x*this.zoom,this.size.y=this.origSize.y*this.zoom,r=map(this.origPos.x,this.pos.x-this.size.x/2,this.pos.x+this.size.x/2,this.x,this.w),l=map(this.origPos.y,this.pos.y-this.size.y/2,this.pos.y+this.size.y/2,this.h,this.y),this.bX=r,this.bY=l}updateDrag(){this.dragging&&(cursor("grabbing"),this.bX=mouseX+this.offsetX,this.bY=mouseY+this.offsetY,this.pos.x=map(this.bX,this.w,this.x,-this.size.x/2,this.size.x/2),this.pos.y=map(this.bY,this.y,this.h,-this.size.y/2,this.size.y/2))}pressedPlot(){0<mouseX&&mouseX<width&&0<mouseY&&mouseY<height&&(this.dragging=!0,this.offsetX=this.bX-mouseX,this.offsetY=this.bY-mouseY)}releasedPlot(){this.dragging=!1}update(){this.zoom;keyIsDown(188)&&this.zoomAt(this.w/2+this.x/2,this.h/2+this.y/2,.95,!1),keyIsDown(190)&&this.zoomAt(this.w/2+this.x/2,this.h/2+this.y/2,.95,!0),keyIsDown(27)&&(this.size.x=this.origSize.x,this.size.y=this.origSize.y,this.pos.x=this.origPos.x,this.pos.y=this.origPos.y,this.zoom=this.origZoom),this.updateDrag()}setPixelRGB(t,s,i,h,e){let o=4*(t+s*width);pixels[o+0]=i,pixels[o+1]=h,pixels[o+2]=e,pixels[o+3]=255}setPixelHSV(t,s,i,h,e){let o,r,l,n,u,a,p,x;switch(a=e*(1-h),p=e*(1-(u=6*i-(n=Math.floor(6*i)))*h),x=e*(1-(1-u)*h),n%6){case 0:o=e,r=x,l=a;break;case 1:o=p,r=e,l=a;break;case 2:o=a,r=e,l=x;break;case 3:o=a,r=p,l=e;break;case 4:o=x,r=a,l=e;break;case 5:o=e,r=a,l=p}this.setPixelRGB(t,s,Math.round(255*o),Math.round(255*r),Math.round(255*l))}setPixelHSL(t,s,i,h,e){let o,r,l;if(0==h)o=r=l=e;else{let t=(t,s,i)=>(i<0&&(i+=1),i>1&&(i-=1),i<1/6?t+6*(s-t)*i:i<.5?s:i<2/3?t+(s-t)*(2/3-i)*6:t),s=e<.5?e*(1+h):e+h-e*h,n=2*e-s;o=t(n,s,i+1/3),r=t(n,s,i),l=t(n,s,i-1/3)}this.setPixelRGB(t,s,Math.round(255*o),Math.round(255*r),Math.round(255*l))}setPixelHSLuv(t,s,i,h,e){let o=4*(t+s*width),r=hsluv.hsluvToRgb([360*i,50*h,50*e]);pixels[o]=255*r[0],pixels[o+1]=255*r[1],pixels[o+2]=255*r[2]}}